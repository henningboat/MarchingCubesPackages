float4 _Time;
#include "Includes/DistanceFieldTriangulation.hlsl"
#include "Includes/DistanceField.hlsl"
#include "Includes/MortonNumbers.hlsl"
#include "Includes/MarchTables.compute"

#pragma kernel ResetSubChunkTriangleCount
#pragma kernel GetTrianglePositions
#pragma kernel BuildIndexBuffer

StructuredBuffer<float4> _NormalBuffer;

StructuredBuffer<float4> _ChunksToTriangulate;

#include "Includes/GlobalDistanceField.hlsl"

RWStructuredBuffer<ClusterTriangle> _TriangleIndices;
RWStructuredBuffer<int> _ChunkTriangleCount;
StructuredBuffer<int> _TriangleCountPerSubChunkResult;

uint triangleWriteIndex = 0;

groupshared int groupTriangleCount = 0;


[numthreads(1,1,1)]
void ResetSubChunkTriangleCount(uint3 id : SV_DispatchThreadID)
{
    const int chunkIndex = GetChunkIndexFromPosition(_ChunksToTriangulate[id.x].xyz);
    _ChunkTriangleCount[chunkIndex] = 0;
}

[numthreads(8,8,8)]
void GetTrianglePositions(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex,
                          uint3 groupThreadID:SV_GroupThreadID)
{
    const int3 terrainChunkBasePosition = _ChunksToTriangulate[id.x / 8];

    int3 positionWS = terrainChunkBasePosition + groupThreadID;
    
    float4 cubeCorners[8] = {
        GetPointPosition((int3(positionWS.x, positionWS.y, positionWS.z))),
        GetPointPosition((int3(positionWS.x + 1, positionWS.y, positionWS.z))),
        GetPointPosition((int3(positionWS.x + 1, positionWS.y, positionWS.z + 1))),
        GetPointPosition((int3(positionWS.x, positionWS.y, positionWS.z + 1))),
        GetPointPosition((int3(positionWS.x, positionWS.y + 1, positionWS.z))),
        GetPointPosition((int3(positionWS.x + 1, positionWS.y + 1, positionWS.z))),
        GetPointPosition((int3(positionWS.x + 1, positionWS.y + 1, positionWS.z + 1))),
        GetPointPosition((int3(positionWS.x, positionWS.y + 1, positionWS.z + 1)))
    };
    
    // Calculate unique index for each cube configuration.
    // There are 256 possible values
    // A value of 0 means cube is entirely inside surface; 255 entirely outside.
    // The value is used to look up the edge table, which indicates which edges of the cube are cut by the isosurface.
    const float isoLevel = 0;
    
    int cubeIndex = 0;
    if (cubeCorners[0].w > isoLevel) cubeIndex |= 1;
    if (cubeCorners[1].w > isoLevel) cubeIndex |= 2;
    if (cubeCorners[2].w > isoLevel) cubeIndex |= 4;
    if (cubeCorners[3].w > isoLevel) cubeIndex |= 8;
    if (cubeCorners[4].w > isoLevel) cubeIndex |= 16;
    if (cubeCorners[5].w > isoLevel) cubeIndex |= 32;
    if (cubeCorners[6].w > isoLevel) cubeIndex |= 64;
    if (cubeCorners[7].w > isoLevel) cubeIndex |= 128;
    
    const int chunkIndex = GetChunkIndexFromPosition(positionWS);
    
    if (cubeIndex == 0 || cubeIndex == 255)
        return;
    
    const int triangleCount = vertexCountPerCubeIndex[cubeIndex] / 3;
    
    int offsetInSubChunk;
    
    InterlockedAdd(_ChunkTriangleCount[chunkIndex], triangleCount, offsetInSubChunk);
    
    const int maxTrianglesPerChunk = k_MaxTrianglesPerChunk * 5;

    const int3 positionInsideChunk = positionWS % k_ChunkLength;

    const int baseIndex = maxTrianglesPerChunk * chunkIndex + offsetInSubChunk;
    
    for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3)
    {
        _TriangleIndices[baseIndex + i / 3] = PackTriangle(positionInsideChunk, cubeIndex, i / 3);
    }
}

RWStructuredBuffer<int> _ArgsBuffer;
//
// [numthreads(1,1,1)]
// void CalculateTriangulationThreadGroupSizeKernel()
// {
//     _ArgsBuffer[1] = ceil(_ArgsBuffer[0] / 512.0f);
// }
//
//
// uint packVertexColor(float4 data)
// {
//     uint packed = 0;
//
//     packed |= uint(data.x) << 24;
//     packed |= uint(data.y) << 16;
//     packed |= uint(data.z) << 8;
//     packed |= uint(data.w);
//
//     return packed;
// }

RWStructuredBuffer<uint> _IndexBufferCounter;
RWStructuredBuffer<ClusterTriangle> _TrianglesToRenderBuffer;

int _TriangulationSubChunkCount;
int _IndexBufferSize;

[numthreads(1,1,1)]
void BuildIndexBuffer(uint3 id : SV_DispatchThreadID)
{
    const int chunkIndex = GetChunkIndexFromPosition(_ChunksToTriangulate[id.x].xyz);

    const int vertexCountOfChunk = _ChunkTriangleCount[chunkIndex];
    int indexBufferOffset = 0;
    InterlockedAdd(_IndexBufferCounter[0], vertexCountOfChunk * 3, indexBufferOffset);

    int maxTrianglesPerSubChunk = 8 * 8 * 8 * 5;

    int vertexOffset = maxTrianglesPerSubChunk * chunkIndex;

    AllMemoryBarrier();

    for (int i = 0; i < maxTrianglesPerSubChunk; i++)
    {
        if (i < vertexCountOfChunk)
        {
            _TrianglesToRenderBuffer[indexBufferOffset / 3 + i] = _TriangleIndices[vertexOffset + i];
        }
    }
}
